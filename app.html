<script>
  // ====== CONFIG ======
  const MODEL_URL = './tm-model/';   // Folder that contains model.json, metadata.json, weights.bin
  const CANVAS_SIZE = 320;           // Display size; model resizes internally
  // ====================

  let model, webcamStream = null, ready = false;

  const fileInput = document.getElementById('file');
  const cameraBtn = document.getElementById('cameraBtn');
  const stopBtn = document.getElementById('stopBtn');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const labelEl = document.getElementById('label');
  const probEl = document.getElementById('prob');

  async function loadModel() {
    labelEl.textContent = 'Label: (loading model…)';
    probEl.textContent = 'Confidence: —';
    try {
      // tmImage is provided by @teachablemachine/image script tag
      model = await tmImage.load(MODEL_URL + 'model.json', MODEL_URL + 'metadata.json');
      const labels = model.getClassLabels ? await model.getClassLabels() : [];
      console.log('Model loaded. Labels:', labels);
      ready = true;
      labelEl.textContent = 'Label: (model ready)';
      probEl.textContent = 'Confidence: —';
      // enable UI
      fileInput.disabled = false;
      cameraBtn.disabled = false;
    } catch (err) {
      console.error('Model load failed:', err);
      labelEl.textContent = 'Label: (model load failed)';
      probEl.textContent = String(err);
    }
  }

  function drawToCanvas(srcEl) {
    const w = CANVAS_SIZE, h = CANVAS_SIZE;
    if (canvas.width !== w) canvas.width = w;
    if (canvas.height !== h) canvas.height = h;
    ctx.drawImage(srcEl, 0, 0, w, h);
  }

  async function predictFromCanvas() {
    if (!ready || !model) return;
    try {
      const preds = await model.predict(canvas);
      if (!preds || !preds.length) {
        console.warn('No predictions returned.');
        return;
      }
      preds.sort((a,b) => b.probability - a.probability);
      const top = preds[0];
      labelEl.textContent = 'Label: ' + top.className;
      probEl.textContent = 'Confidence: ' + (top.probability*100).toFixed(1) + '%';
      console.log('Predictions:', preds);
    } catch (err) {
      console.error('Predict error:', err);
      probEl.textContent = 'Predict error: ' + err.message;
    }
  }

  // Disable controls until model is ready
  fileInput.disabled = true;
  cameraBtn.disabled = true;

  fileInput.addEventListener('change', async (e) => {
    if (!ready) return;
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = async () => {
      drawToCanvas(img);
      await predictFromCanvas();
    };
    img.onerror = (err) => console.error('Image load error:', err);
    img.src = URL.createObjectURL(file);
  });

  cameraBtn.addEventListener('click', async () => {
    if (!ready) return;
    try {
      webcamStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
      video.srcObject = webcamStream;
      video.style.display = 'block';
      await video.play();

      const tick = async () => {
        if (!webcamStream) return;
        drawToCanvas(video);
        await predictFromCanvas();
        requestAnimationFrame(tick);
      };
      tick();
      stopBtn.disabled = false;
    } catch (err) {
      alert('Camera error: ' + err.message);
      console.error(err);
    }
  });

  stopBtn.addEventListener('click', () => {
    if (webcamStream) {
      webcamStream.getTracks().forEach(t => t.stop());
      webcamStream = null;
      video.style.display = 'none';
      stopBtn.disabled = true;
    }
  });

  // Kick off
  loadModel();

  // Helpful: force a hard refresh if assets cache strangely
  // (You can comment this out after first good run)
  // if ('serviceWorker' in navigator) { caches?.keys?.().then(keys => keys.forEach(k => caches.delete(k))); }
</script>
